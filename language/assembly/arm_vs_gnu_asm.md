# ARM Assembly vs GNU Assembly
I find pretty frequuently that I'll come across a situation where development with both ARM assembler and
the GNU assembler is used. Given that I haven't done much with either of these before, I wanted to create
a running list of things I find in my own research for how to do similar things in both languages.

Helpful Resources for ARM:\
[ARM Assembler Official Docs](https://developer.arm.com/documentation/dui0068/b/directives-reference/miscellaneous-directives/import)

Helpful Resources for GNU:\
[GNU Assembler Official Docs](https://sourceware.org/binutils/docs/as/)\
[Statement Quick Reference](https://www.ic.unicamp.br/~celio/mc404-2014/docs/gnu-arm-directives.pdf)

# Importing and Exporting Symbols
## ARM
[IMPORT](https://developer.arm.com/documentation/dui0068/b/directives-reference/miscellaneous-directives/import?lang=en)\
[EXPORT](https://developer.arm.com/documentation/dui0068/b/directives-reference/miscellaneous-directives/export-or-global?lang=en)
[EXTERN](https://developer.arm.com/documentation/dui0068/b/directives-reference/miscellaneous-directives/extern?lang=en)

From the documentation above:\
"The IMPORT directive provides the assembler with a name that is not defined in the current assembly."\
"The EXTERN directive provides the assembler with a name that is not defined in the current assembly."\
"The EXPORT directive declares a symbol that can be used by the linker to resolve symbol references in
separate object and library files. GLOBAL is a synonym for EXPORT."\

### Difference Between IMPORT & EXTERN
EXTERN is very similar to IMPORT, except that the name is not imported if no reference to it is found in the current assembly.

### What the heck are those "Image$$" imports?
[Image$$ Execution Region Symbols](https://developer.arm.com/documentation/dui0474/c/accessing-and-managing-symbols-with-armlink/image---execution-region-symbols?lang=en)\
These appear to be special symbols generated by the linker for every execution region present in the image. I would imagine that somehow
this ends up being tied to the linker script sections. It looks like they are automatically generated. Very nice.

## GNU
Doesn't have any symbol importing. If you need it, you simply just use it and allow the linker to notify you of any undefined symbols.
For exports, it's required to use the '.global' keyword.

```assembly
.global some_cool_function
some_cool_function:
  <function_body>
```

# Constants and Literals
## ARM
[EQU Documentation](https://developer.arm.com/documentation/dui0489/i/directives-reference/equ)
Constants can be created with the EQU statement. See the documentation above for the correct statement formatting.
```assembly
abc EQU 2               ; assigns the value 2 to the symbol abc.
xyz EQU label+8         ; assigns the address (label+8) to the
                        ; symbol xyz.
fiq EQU 0x1C, CODE32    ; assigns the absolute address 0x1C to
                        ; the symbol fiq, and marks it as code
```

## GNU
[.equ Documentation](https://sourceware.org/binutils/docs/as/Equ.html#Equ)
Very similar to ARM. Mostly just using a '.equ' instead of 'EQU'.


# Include-ing Other Files
Both ARM and GNU behave the same, which is very similar to the '#include' statement in C/C++. A valid assembly file can be included with
these commands and have their contents injected at the point of inclusion. This is useful for importing constants and other common
declarations.

## ARM
[GET or INCLUDE](https://developer.arm.com/documentation/dui0489/h/directives-reference/get-or-include)
## GNU
[.include](https://sourceware.org/binutils/docs/as/Include.html#Include)


# Defining Attributes of Code Sections
## ARM
### AREA Statments
[AREA](https://developer.arm.com/documentation/dui0041/c/assembler/directives/area-directive)
These statements tell the linker that there is a new section of code to be assembled. You give several properties that define attributes
on the following code, like it's alignment, read/write abilities, instruction mode, etc.

### ARM, THUMB, CODE16, CODE32
Instruct the assmbler how to interpret the following code

# Related Tags
[[scatter_files]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[scatter_files]: ../linker/scatter_files "Scatter Files in ARM Linker"
[//end]: # "Autogenerated link references"